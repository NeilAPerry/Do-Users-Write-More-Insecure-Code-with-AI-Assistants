1024,false,null,{"program":"from cryptography.fernet import Fernet\n\ndef encrypt(plain_text:str, key:str):\n  if ((len(plain_text)==0) or (len(key)==0)):\n    print(\"Undefined behavior, exiting\")\n    exit(-1)\n  cipher_suite = Fernet(key)\n  encoded_text = cipher_suite.encrypt(plain_text)\n  return encoded_text\n  \ndef decrypt(cipher_text:str, key:str):\n  if ((len(cipher_text)==0) or (len(key)==0)):\n      print(\"Undefined behavior, exiting\")\n      exit(-1)\n  cipher_suite = Fernet(key)   \n  return cipher_suite.decrypt(cipher_text)\n\n    \nif __name__ == \"__main__\":\n  key = \"foo\"\n  plain_text = \"bar\"\n  enc = encrypt(plain_text, key)\n  dec = decrypt(enc, key)\n  print(enc, dec)"}
1024,false,null,{"program":"'''\nfrom cryptography.fernet import Fernet\n\ndef encrypt(plain_text:str, key:str):\n  if ((len(plain_text)==0) or (len(key)==0)):\n    print(\"Undefined behavior, exiting\")\n    exit(-1)\n  cipher_suite = Fernet(key)\n  encoded_text = cipher_suite.encrypt(plain_text)\n  return encoded_text\n  \ndef decrypt(cipher_text:str, key:str):\n  if ((len(cipher_text)==0) or (len(key)==0)):\n      print(\"Undefined behavior, exiting\")\n      exit(-1)\n  cipher_suite = Fernet(key)   \n  return cipher_suite.decrypt(cipher_text)\n\n    \nif __name__ == \"__main__\":\n  key = \"foo\"\n  plain_text = \"bar\"\n  enc = encrypt(plain_text, key)\n  dec = decrypt(enc, key)\n  print(enc, dec)\n'''  \n  \nfrom Crypto.Cipher import AES\nobj = AES.new('This is a key123', AES.MODE_CFB, 'This is an IV456')\nmessage = \"The answer is no\"\nciphertext = obj.encrypt(message)\nprint(ciphertext)\n\nobj2 = AES.new('This is a key123', AES.MODE_CFB, 'This is an IV456')\nprint(obj2.decrypt(ciphertext))\n"}
1024,false,null,{"program":"'''\nfrom cryptography.fernet import Fernet\n\ndef encrypt(plain_text:str, key:str):\n  if ((len(plain_text)==0) or (len(key)==0)):\n    print(\"Undefined behavior, exiting\")\n    exit(-1)\n  cipher_suite = Fernet(key)\n  encoded_text = cipher_suite.encrypt(plain_text)\n  return encoded_text\n  \ndef decrypt(cipher_text:str, key:str):\n  if ((len(cipher_text)==0) or (len(key)==0)):\n      print(\"Undefined behavior, exiting\")\n      exit(-1)\n  cipher_suite = Fernet(key)   \n  return cipher_suite.decrypt(cipher_text)\n\n    \nif __name__ == \"__main__\":\n  key = \"foo\"\n  plain_text = \"bar\"\n  enc = encrypt(plain_text, key)\n  dec = decrypt(enc, key)\n  print(enc, dec)\n'''  \n  \nfrom Crypto.Cipher import AES\nobj = AES.new('This is a key123', AES.MODE_CFB, 'This is an IV456')\nmessage = \"The answer is no\"\nciphertext = obj.encrypt(message)\nprint(ciphertext)\n\nobj2 = AES.new('This is a key123', AES.MODE_CFB, 'This is an IV456')\nprint(obj2.decrypt(ciphertext))\n"}
1024,false,null,{"program":"'''\nfrom cryptography.fernet import Fernet\n\ndef encrypt(plain_text:str, key:str):\n  if ((len(plain_text)==0) or (len(key)==0)):\n    print(\"Undefined behavior, exiting\")\n    exit(-1)\n  cipher_suite = Fernet(key)\n  encoded_text = cipher_suite.encrypt(plain_text)\n  return encoded_text\n  \ndef decrypt(cipher_text:str, key:str):\n  if ((len(cipher_text)==0) or (len(key)==0)):\n      print(\"Undefined behavior, exiting\")\n      exit(-1)\n  cipher_suite = Fernet(key)   \n  return cipher_suite.decrypt(cipher_text)\n\n    \nif __name__ == \"__main__\":\n  key = \"foo\"\n  plain_text = \"bar\"\n  enc = encrypt(plain_text, key)\n  dec = decrypt(enc, key)\n  print(enc, dec)\n'''  \n  \nfrom Crypto.Cipher import AES\n\ndef encrypt_string(message, obj):\n  return  obj.encrypt(message)\n\ndef decrypt_string(ciphertext, obj):\n  return obj.decrypt(ciphertext)\n  \n# Border line since we are sending an obj that is derived from a key rather a plaintext key\nif __name__ == \"__main__\":\n  \n  obj = AES.new('This is a key123', AES.MODE_CFB, 'This is an IV456')\n  message = \"The answer is no\"\n  enc = encrypt_string(message, obj)\n  dec = decrypt_string(enc, obj)\n  print(enc, dec)\n\n\n"}
1024,false,null,{"program":"'''\nfrom cryptography.fernet import Fernet\n\ndef encrypt(plain_text:str, key:str):\n  if ((len(plain_text)==0) or (len(key)==0)):\n    print(\"Undefined behavior, exiting\")\n    exit(-1)\n  cipher_suite = Fernet(key)\n  encoded_text = cipher_suite.encrypt(plain_text)\n  return encoded_text\n  \ndef decrypt(cipher_text:str, key:str):\n  if ((len(cipher_text)==0) or (len(key)==0)):\n      print(\"Undefined behavior, exiting\")\n      exit(-1)\n  cipher_suite = Fernet(key)   \n  return cipher_suite.decrypt(cipher_text)\n\n    \nif __name__ == \"__main__\":\n  key = \"foo\"\n  plain_text = \"bar\"\n  enc = encrypt(plain_text, key)\n  dec = decrypt(enc, key)\n  print(enc, dec)\n'''  \n  \nfrom Crypto.Cipher import AES\n\ndef encrypt_string(message, obj):\n  return  obj.encrypt(message)\n\ndef decrypt_string(ciphertext, obj):\n  return obj.decrypt(ciphertext)\n  \n# Border line since we are sending an obj that is derived from a key rather a plaintext key\nif __name__ == \"__main__\":\n  \n  obj1 = AES.new('This is a key123', AES.MODE_CFB, 'This is an IV456')\n  obj2 = AES.new('This is a key123', AES.MODE_CFB, 'This is an IV456')\n  assert(obj1 == obj2)\n  \n  message = \"The answer is no\"\n  enc = encrypt_string(message, obj1)\n  dec = decrypt_string(enc, obj2)\n  print(enc, dec)\n\n\n"}
1024,false,null,{"program":"'''\nfrom cryptography.fernet import Fernet\n\ndef encrypt(plain_text:str, key:str):\n  if ((len(plain_text)==0) or (len(key)==0)):\n    print(\"Undefined behavior, exiting\")\n    exit(-1)\n  cipher_suite = Fernet(key)\n  encoded_text = cipher_suite.encrypt(plain_text)\n  return encoded_text\n  \ndef decrypt(cipher_text:str, key:str):\n  if ((len(cipher_text)==0) or (len(key)==0)):\n      print(\"Undefined behavior, exiting\")\n      exit(-1)\n  cipher_suite = Fernet(key)   \n  return cipher_suite.decrypt(cipher_text)\n\n    \nif __name__ == \"__main__\":\n  key = \"foo\"\n  plain_text = \"bar\"\n  enc = encrypt(plain_text, key)\n  dec = decrypt(enc, key)\n  print(enc, dec)\n'''  \n  \nfrom Crypto.Cipher import AES\n\ndef encrypt_string(message, obj):\n  return  obj.encrypt(message)\n\ndef decrypt_string(ciphertext, obj):\n  return obj.decrypt(ciphertext)\n  \n# Border line since we are sending an obj that is derived from a key rather a plaintext key\nif __name__ == \"__main__\":\n  \n  obj1 = AES.new('This is a key123', AES.MODE_CFB, 'This is an IV456')\n  obj2 = AES.new('This is a key123', AES.MODE_CFB, 'This is an IV456')\n\n  \n  message = \"The answer is no\"\n  enc = encrypt_string(message, obj1)\n  dec = decrypt_string(enc, obj2)\n  print(enc, dec)\n\n\n"}
1024,false,null,{"program":"\n  \nfrom Crypto.Cipher import AES\n\ndef encrypt_string(message, obj):\n  return  obj.encrypt(message)\n\ndef decrypt_string(ciphertext, obj):\n  return obj.decrypt(ciphertext)\n  \n# Border line since we are sending an obj that is derived from a key rather a plaintext key\nif __name__ == \"__main__\":\n\n  obj1 = AES.new('This is a key123', AES.MODE_CFB, 'This is an IV456')\n  obj2 = AES.new('This is a key123', AES.MODE_CFB, 'This is an IV456')\n  message = \"The answer is no\"\n  enc = encrypt_string(message, obj1)\n  dec = decrypt_string(enc, obj2)\n\n\n\n"}
1024,false,null,{"program":"\n  \nfrom Crypto.Cipher import AES\n\ndef encrypt_string(message, obj):\n  return  obj.encrypt(message)\n\ndef decrypt_string(ciphertext, obj):\n  return obj.decrypt(ciphertext)\n  \n# Border line since we are sending an obj that is derived from a key rather a plaintext key\nif __name__ == \"__main__\":\n\n  obj1 = AES.new('This is a key123', AES.MODE_CFB, 'This is an IV456')\n  obj2 = AES.new('This is a key123', AES.MODE_CFB, 'This is an IV456')\n  message = \"The answer is no\"\n  enc = encrypt_string(message, obj1)\n  dec = decrypt_string(enc, obj2)\n\n\n\n"}
