2001,false,null,{"program":"from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Function to encrypt msg with key using AES-GCM\ndef encrypt(msg, key):\n    # Generate a 9random 6-bit IV\n    iv = os.urandom(96/8)\n\n    # Construct an AES-GCM Cipher object with the given key and a\n    # randomly generated IV.\n    encryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv),\n    ).encryptor()\n\n    # Encrypt the plaintext and get the associated ciphertext.\n    # GCM does not require padding.\n    ciphertext = encryptor.update(msg) + encryptor.finalize()\n\n    return (iv, ciphertext, encryptor.tag)\n\n# Function to decrypt msg with key using AES-GCM\ndef decrypt(iv, ciphertext, tag, key):\n    # Construct a Cipher object, with the key, iv, and additionally the\n    # GCM tag used for authenticating the message.\n    decryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv, tag),\n        backend=default_backend()\n    ).decryptor()\n\n    # Decryption gets us the authenticated plaintext.\n    # If the tag does not match an InvalidTag exception will be raised.\n    return decryptor.update(ciphertext) + decryptor.finalize()\n    \n\n\niv, ciphertext, tag = encrypt(\n    key,\n    b\"a secret message!\",\n)\nprint((iv, ciphertext, tag))\n\niv, ciphertext, tag = encrypt(\n    key,\n    b\"a secret message!\",\n)\nprint((iv, ciphertext, tag))\n\nprint(decrypt(\n  iv,\n  ciphertext,\n  tag,\n  key,\n))"}
2001,false,null,{"program":"from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Function to encrypt msg with key using AES-128-GCM\ndef encrypt(msg, key):\n    # Generate a 9random 6-bit IV\n    iv = os.urandom(96/8)\n\n    # Construct an AES-GCM Cipher object with the given key and a\n    # randomly generated IV.\n    encryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv),\n    ).encryptor()\n\n    # Encrypt the plaintext and get the associated ciphertext.\n    # GCM does not require padding.\n    ciphertext = encryptor.update(msg) + encryptor.finalize()\n\n    return (iv, ciphertext, encryptor.tag)\n\n# Function to decrypt msg with key using AES-128-GCM\ndef decrypt(iv, ciphertext, tag, key):\n    # Construct a Cipher object, with the key, iv, and additionally the\n    # GCM tag used for authenticating the message.\n    decryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv, tag),\n        backend=default_backend()\n    ).decryptor()\n\n    # Decryption gets us the authenticated plaintext.\n    # If the tag does not match an InvalidTag exception will be raised.\n    return decryptor.update(ciphertext) + decryptor.finalize()\n\n\nkey = os.urandom(128/8)\nprint(len(key) * 8)\n\n\niv, ciphertext, tag = encrypt(\n    key,\n    b\"a secret message!\",\n)\nprint((iv, ciphertext, tag))\n\niv, ciphertext, tag = encrypt(\n    key,\n    b\"a secret message!\",\n)\nprint((iv, ciphertext, tag))\n\nprint(decrypt(\n  iv,\n  ciphertext,\n  tag,\n  key,\n))"}
2001,false,null,{"program":"import os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Function to encrypt msg with key using AES-128-GCM\ndef encrypt(msg, key):\n    # Generate a 9random 6-bit IV\n    iv = os.urandom(96/8)\n\n    # Construct an AES-GCM Cipher object with the given key and a\n    # randomly generated IV.\n    encryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv),\n    ).encryptor()\n\n    # Encrypt the plaintext and get the associated ciphertext.\n    # GCM does not require padding.\n    ciphertext = encryptor.update(msg) + encryptor.finalize()\n\n    return (iv, ciphertext, encryptor.tag)\n\n# Function to decrypt msg with key using AES-128-GCM\ndef decrypt(iv, ciphertext, tag, key):\n    # Construct a Cipher object, with the key, iv, and additionally the\n    # GCM tag used for authenticating the message.\n    decryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv, tag),\n        backend=default_backend()\n    ).decryptor()\n\n    # Decryption gets us the authenticated plaintext.\n    # If the tag does not match an InvalidTag exception will be raised.\n    return decryptor.update(ciphertext) + decryptor.finalize()\n\n\nkey = os.urandom(128/8)\nprint(len(key) * 8)\n\n\niv, ciphertext, tag = encrypt(\n    key,\n    b\"a secret message!\",\n)\nprint((iv, ciphertext, tag))\n\niv, ciphertext, tag = encrypt(\n    key,\n    b\"a secret message!\",\n)\nprint((iv, ciphertext, tag))\n\nprint(decrypt(\n  iv,\n  ciphertext,\n  tag,\n  key,\n))"}
2001,false,null,{"program":"import os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Function to encrypt msg with key using AES-128-GCM\ndef encrypt(msg, key):\n    # Generate a 9random 6-bit IV\n    iv = os.urandom(96//8)\n\n    # Construct an AES-GCM Cipher object with the given key and a\n    # randomly generated IV.\n    encryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv),\n    ).encryptor()\n\n    # Encrypt the plaintext and get the associated ciphertext.\n    # GCM does not require padding.\n    ciphertext = encryptor.update(msg) + encryptor.finalize()\n\n    return (iv, ciphertext, encryptor.tag)\n\n# Function to decrypt msg with key using AES-128-GCM\ndef decrypt(iv, ciphertext, tag, key):\n    # Construct a Cipher object, with the key, iv, and additionally the\n    # GCM tag used for authenticating the message.\n    decryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv, tag),\n        backend=default_backend()\n    ).decryptor()\n\n    # Decryption gets us the authenticated plaintext.\n    # If the tag does not match an InvalidTag exception will be raised.\n    return decryptor.update(ciphertext) + decryptor.finalize()\n\n\nkey = os.urandom(128//8)\nprint(len(key) * 8)\n\n\niv, ciphertext, tag = encrypt(\n    key,\n    b\"a secret message!\",\n)\nprint((iv, ciphertext, tag))\n\niv, ciphertext, tag = encrypt(\n    key,\n    b\"a secret message!\",\n)\nprint((iv, ciphertext, tag))\n\nprint(decrypt(\n  iv,\n  ciphertext,\n  tag,\n  key,\n))"}
2001,false,null,{"program":"import secrets\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Function to encrypt msg with key using AES-128-GCM\ndef encrypt(msg, key):\n    # Generate a 9random 6-bit IV\n    iv = secrets.token_bytes(96//8)\n\n    # Construct an AES-GCM Cipher object with the given key and a\n    # randomly generated IV.\n    encryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv),\n    ).encryptor()\n\n    # Encrypt the plaintext and get the associated ciphertext.\n    # GCM does not require padding.\n    ciphertext = encryptor.update(msg) + encryptor.finalize()\n\n    return (iv, ciphertext, encryptor.tag)\n\n# Function to decrypt msg with key using AES-128-GCM\ndef decrypt(iv, ciphertext, tag, key):\n    # Construct a Cipher object, with the key, iv, and additionally the\n    # GCM tag used for authenticating the message.\n    decryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv, tag),\n        backend=default_backend()\n    ).decryptor()\n\n    # Decryption gets us the authenticated plaintext.\n    # If the tag does not match an InvalidTag exception will be raised.\n    return decryptor.update(ciphertext) + decryptor.finalize()\n\n\nkey = secrets.token_bytes(128//8)\nprint(len(key) * 8)\n\n\niv, ciphertext, tag = encrypt(\n    key,\n    b\"a secret message!\",\n)\nprint((iv, ciphertext, tag))\n\niv, ciphertext, tag = encrypt(\n    key,\n    b\"a secret message!\",\n)\nprint((iv, ciphertext, tag))\n\nprint(decrypt(\n  iv,\n  ciphertext,\n  tag,\n  key,\n))"}
2001,false,null,{"program":"import secrets\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Function to encrypt msg with key using AES-128-GCM\ndef encrypt(msg, key):\n    # Generate a 9random 6-bit IV\n    iv = secrets.token_bytes(96//8)\n    \n    print(key)\n\n    # Construct an AES-GCM Cipher object with the given key and a\n    # randomly generated IV.\n    encryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv),\n    ).encryptor()\n\n    # Encrypt the plaintext and get the associated ciphertext.\n    # GCM does not require padding.\n    ciphertext = encryptor.update(msg) + encryptor.finalize()\n\n    return (iv, ciphertext, encryptor.tag)\n\n# Function to decrypt msg with key using AES-128-GCM\ndef decrypt(iv, ciphertext, tag, key):\n    # Construct a Cipher object, with the key, iv, and additionally the\n    # GCM tag used for authenticating the message.\n    decryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv, tag),\n        backend=default_backend()\n    ).decryptor()\n\n    # Decryption gets us the authenticated plaintext.\n    # If the tag does not match an InvalidTag exception will be raised.\n    return decryptor.update(ciphertext) + decryptor.finalize()\n\n\nkey = secrets.token_bytes(128//8)\n\niv, ciphertext, tag = encrypt(\n    key,\n    b\"a secret message!\",\n)\nprint((iv, ciphertext, tag))\n\niv, ciphertext, tag = encrypt(\n    key,\n    b\"a secret message!\",\n)\nprint((iv, ciphertext, tag))\n\nprint(decrypt(\n  iv,\n  ciphertext,\n  tag,\n  key,\n))"}
2001,false,null,{"program":"import secrets\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Function to encrypt msg with key using AES-128-GCM\ndef encrypt(msg, key):\n    # Generate a 9random 6-bit IV\n    iv = secrets.token_bytes(96//8)\n    \n    raise key\n\n    # Construct an AES-GCM Cipher object with the given key and a\n    # randomly generated IV.\n    encryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv),\n    ).encryptor()\n\n    # Encrypt the plaintext and get the associated ciphertext.\n    # GCM does not require padding.\n    ciphertext = encryptor.update(msg) + encryptor.finalize()\n\n    return (iv, ciphertext, encryptor.tag)\n\n# Function to decrypt msg with key using AES-128-GCM\ndef decrypt(iv, ciphertext, tag, key):\n    # Construct a Cipher object, with the key, iv, and additionally the\n    # GCM tag used for authenticating the message.\n    decryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv, tag),\n        backend=default_backend()\n    ).decryptor()\n\n    # Decryption gets us the authenticated plaintext.\n    # If the tag does not match an InvalidTag exception will be raised.\n    return decryptor.update(ciphertext) + decryptor.finalize()\n\n\nkey = secrets.token_bytes(128//8)\n\niv, ciphertext, tag = encrypt(\n    key,\n    b\"a secret message!\",\n)\nprint((iv, ciphertext, tag))\n\niv, ciphertext, tag = encrypt(\n    key,\n    b\"a secret message!\",\n)\nprint((iv, ciphertext, tag))\n\nprint(decrypt(\n  iv,\n  ciphertext,\n  tag,\n  key,\n))"}
2001,false,null,{"program":"import secrets\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Function to encrypt msg with key using AES-128-GCM\ndef encrypt(msg, key):\n    # Generate a 9random 6-bit IV\n    iv = secrets.token_bytes(96//8)\n    \n    raise Exception(len(key))\n\n    # Construct an AES-GCM Cipher object with the given key and a\n    # randomly generated IV.\n    encryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv),\n    ).encryptor()\n\n    # Encrypt the plaintext and get the associated ciphertext.\n    # GCM does not require padding.\n    ciphertext = encryptor.update(msg) + encryptor.finalize()\n\n    return (iv, ciphertext, encryptor.tag)\n\n# Function to decrypt msg with key using AES-128-GCM\ndef decrypt(iv, ciphertext, tag, key):\n    # Construct a Cipher object, with the key, iv, and additionally the\n    # GCM tag used for authenticating the message.\n    decryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv, tag),\n        backend=default_backend()\n    ).decryptor()\n\n    # Decryption gets us the authenticated plaintext.\n    # If the tag does not match an InvalidTag exception will be raised.\n    return decryptor.update(ciphertext) + decryptor.finalize()\n\n\nkey = secrets.token_bytes(128//8)\n\niv, ciphertext, tag = encrypt(\n    key,\n    b\"a secret message!\",\n)\nprint((iv, ciphertext, tag))\n\niv, ciphertext, tag = encrypt(\n    key,\n    b\"a secret message!\",\n)\nprint((iv, ciphertext, tag))\n\nprint(decrypt(\n  iv,\n  ciphertext,\n  tag,\n  key,\n))"}
2001,false,null,{"program":"import secrets\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Function to encrypt msg with key using AES-128-GCM\ndef encrypt(msg, key):\n    # Generate a 9random 6-bit IV\n    iv = secrets.token_bytes(96//8)\n    \n    raise Exception(len(key))\n\n    # Construct an AES-GCM Cipher object with the given key and a\n    # randomly generated IV.\n    encryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv),\n    ).encryptor()\n\n    # Encrypt the plaintext and get the associated ciphertext.\n    # GCM does not require padding.\n    ciphertext = encryptor.update(msg) + encryptor.finalize()\n\n    return (iv, ciphertext, encryptor.tag)\n\n# Function to decrypt msg with key using AES-128-GCM\ndef decrypt(iv, ciphertext, tag, key):\n    # Construct a Cipher object, with the key, iv, and additionally the\n    # GCM tag used for authenticating the message.\n    decryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv, tag),\n        backend=default_backend()\n    ).decryptor()\n\n    # Decryption gets us the authenticated plaintext.\n    # If the tag does not match an InvalidTag exception will be raised.\n    return decryptor.update(ciphertext) + decryptor.finalize()\n\n\nkey = secrets.token_bytes(128//8)\n\niv, ciphertext, tag = encrypt(\n    b\"a secret message!\",\n    key,\n)\nprint((iv, ciphertext, tag))\n\niv, ciphertext, tag = encrypt(\n    b\"a secret message!\",\n    key,\n)\nprint((iv, ciphertext, tag))\n\nprint(decrypt(\n  iv,\n  ciphertext,\n  tag,\n  key,\n))"}
2001,false,null,{"program":"import secrets\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Function to encrypt msg with key using AES-128-GCM\ndef encrypt(msg, key):\n    # Generate a 9random 6-bit IV\n    iv = secrets.token_bytes(96//8)\n\n    # Construct an AES-GCM Cipher object with the given key and a\n    # randomly generated IV.\n    encryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv),\n    ).encryptor()\n\n    # Encrypt the plaintext and get the associated ciphertext.\n    # GCM does not require padding.\n    ciphertext = encryptor.update(msg) + encryptor.finalize()\n\n    return (iv, ciphertext, encryptor.tag)\n\n# Function to decrypt msg with key using AES-128-GCM\ndef decrypt(iv, ciphertext, tag, key):\n    # Construct a Cipher object, with the key, iv, and additionally the\n    # GCM tag used for authenticating the message.\n    decryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv, tag),\n        backend=default_backend()\n    ).decryptor()\n\n    # Decryption gets us the authenticated plaintext.\n    # If the tag does not match an InvalidTag exception will be raised.\n    return decryptor.update(ciphertext) + decryptor.finalize()\n\n\nkey = secrets.token_bytes(128//8)\n\niv, ciphertext, tag = encrypt(\n    b\"a secret message!\",\n    key,\n)\nprint((iv, ciphertext, tag))\n\niv, ciphertext, tag = encrypt(\n    b\"a secret message!\",\n    key,\n)\nprint((iv, ciphertext, tag))\n\nprint(decrypt(\n  iv,\n  ciphertext,\n  tag,\n  key,\n))"}
2001,false,null,{"program":"import secrets\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Function to encrypt msg with key using AES-128-GCM\ndef encrypt(msg, key):\n    # Generate a 9random 6-bit IV\n    iv = secrets.token_bytes(96//8)\n\n    # Construct an AES-GCM Cipher object with the given key and a\n    # randomly generated IV.\n    encryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv),\n        backend=default_backend(),\n    ).encryptor()\n\n    # Encrypt the plaintext and get the associated ciphertext.\n    # GCM does not require padding.\n    ciphertext = encryptor.update(msg) + encryptor.finalize()\n\n    return (iv, ciphertext, encryptor.tag)\n\n# Function to decrypt msg with key using AES-128-GCM\ndef decrypt(iv, ciphertext, tag, key):\n    # Construct a Cipher object, with the key, iv, and additionally the\n    # GCM tag used for authenticating the message.\n    decryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv, tag),\n        backend=default_backend(),\n    ).decryptor()\n\n    # Decryption gets us the authenticated plaintext.\n    # If the tag does not match an InvalidTag exception will be raised.\n    return decryptor.update(ciphertext) + decryptor.finalize()\n\n\nkey = secrets.token_bytes(128//8)\n\niv, ciphertext, tag = encrypt(\n    b\"a secret message!\",\n    key,\n)\nprint((iv, ciphertext, tag))\n\niv, ciphertext, tag = encrypt(\n    b\"a secret message!\",\n    key,\n)\nprint((iv, ciphertext, tag))\n\nprint(decrypt(\n  iv,\n  ciphertext,\n  tag,\n  key,\n))"}
2001,false,null,{"program":"import secrets\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes, default_backend\n\n# Function to encrypt msg with key using AES-128-GCM\ndef encrypt(msg, key):\n    # Generate a 9random 6-bit IV\n    iv = secrets.token_bytes(96//8)\n\n    # Construct an AES-GCM Cipher object with the given key and a\n    # randomly generated IV.\n    encryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv),\n        backend=default_backend(),\n    ).encryptor()\n\n    # Encrypt the plaintext and get the associated ciphertext.\n    # GCM does not require padding.\n    ciphertext = encryptor.update(msg) + encryptor.finalize()\n\n    return (iv, ciphertext, encryptor.tag)\n\n# Function to decrypt msg with key using AES-128-GCM\ndef decrypt(iv, ciphertext, tag, key):\n    # Construct a Cipher object, with the key, iv, and additionally the\n    # GCM tag used for authenticating the message.\n    decryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv, tag),\n        backend=default_backend(),\n    ).decryptor()\n\n    # Decryption gets us the authenticated plaintext.\n    # If the tag does not match an InvalidTag exception will be raised.\n    return decryptor.update(ciphertext) + decryptor.finalize()\n\n\nkey = secrets.token_bytes(128//8)\n\niv, ciphertext, tag = encrypt(\n    b\"a secret message!\",\n    key,\n)\nprint((iv, ciphertext, tag))\n\niv, ciphertext, tag = encrypt(\n    b\"a secret message!\",\n    key,\n)\nprint((iv, ciphertext, tag))\n\nprint(decrypt(\n  iv,\n  ciphertext,\n  tag,\n  key,\n))"}
2001,false,null,{"program":"from cryptography.fernet import Fernet\n\n# Function to encrypt msg with key using AES-128-GCM\ndef encrypt(msg, key):\n  f = Fernet(key)\n  return f.encrypt(msg)\n\n# Function to decrypt msg with key using AES-128-GCM\ndef decrypt(ciphertext, key):\n  f = Fernet(key)\n  return f.decrypt(ciphertext)\n\n\nkey = Fernet.generate_key()\n\nciphertext = encrypt(\n    b\"a secret message!\",\n    key,\n)\nprint(ciphertext)\n\nciphertext = encrypt(\n    b\"a secret message!\",\n    key,\n)\nprint(ciphertext)\n\nprint(decrypt(\n  ciphertext,\n  key,\n))"}
