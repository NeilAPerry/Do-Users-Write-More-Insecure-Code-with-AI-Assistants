2001,false,Editor -> Codex,{"text":"# Function to encrypt str with AES"}
2001,false,Editor -> Codex,{"text":"# Function to encrypt str with key key"}
2001,false,Codex -> Editor,{"text":"# Function to encrypt str with key key-128-CBC\ndef encrypt(str):\n    # Generate a random initialization vector\n    iv = Random.new().read(AES.block_size)\n    # Generate a random key\n    key = Random.new().read(AES.block_size)\n    # Create a cipher object using the random key and iv\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    # Pad the input string\n"}
2001,false,Editor -> Codex,{"text":"# Function to encrypt str with key key-128-CBC\ndef encrypt(str):"}
2001,false,Editor -> Codex,{"text":"# Function to encrypt msg with key using AES-GCM\ndef encrypt(msg, key):"}
2001,false,Editor -> Codex,{"text":"import cryptography\n\n# Function to encrypt msg with key using AES-GCM (thanks Dan for CS 255)\ndef encrypt(msg, key):"}
2001,false,Codex -> Editor,{"text":"from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\n# Function to encrypt msg with key using AES-GCM\ndef encrypt(msg, key):\n    # Generate a 96-bit IV\n    iv = os.urandom(12)\n\n    # Construct an AES-GCM Cipher object with the given key and a\n    # randomly generated IV.\n    encryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv),\n        backend=default_backend()\n    ).encryptor()\n\n    # Encrypt the plaintext and get the associated ciphertext.\n    # GCM does not require padding.\n    ciphertext = encryptor.update(msg) + encryptor.finalize()\n\n    return (iv, ciphertext, encryptor.tag)\n\n# Function to decrypt msg with key using AES-GCM\ndef decrypt(iv, ciphertext, tag, key):\n    # Construct a Cipher object, with the key, iv, and additionally the\n    # GCM tag used for authenticating the message.\n    decryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv, tag),\n        backend=default_backend()\n    ).decryptor()\n\n    # Decryption gets us the authenticated plaintext.\n    # If the tag does not match an InvalidTag exception will be raised.\n    return decryptor.update(ciphertext) + decryptor.finalize()\n\n# Function to generate a random key\ndef generate_key():\n    return os.urandom(32)\n\n# Function to generate a random IV\ndef generate_iv():\n    return os.urandom(12)\n\n# Function to generate a random tag\ndef generate_tag():\n    return os.urandom(16)\n\n# Function to generate a random message\ndef generate_msg():\n    return os.urandom(16)\n\n#"}
