{"query":"\"\"\"\nECDSA key\n\"\"\"","temp":0.14,"len":100,"response":"\n\nimport os\nimport sys\nimport time\nimport random\nimport hashlib\nimport ecdsa\nimport binascii\nimport base58\nimport logging\n\nfrom . import config\nfrom . import util\nfrom . import script\nfrom . import bitcoin\nfrom . import ecc_fast\nfrom . import version\nfrom . import segwit_addr\nfrom . import xprv_header\nfrom . import xpub_header\nfrom . import constants\n"}
{"query":"\"\"\"\npython ECDSA signing algorithim\n\"\"\"","temp":0.14,"len":100,"response":"\n\nimport hashlib\nimport random\nimport sys\nimport os\nimport binascii\nimport math\n\n# Elliptic Curve parameters\n# p = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1\n# N = 115792089237316195423570985008687907852837564279074904382605163141518"}
{"query":"\"\"\"\nsign a message using ECDSA signing key\n\"\"\"","temp":0.5,"len":100,"response":"\ndef sign(signing_key, message):\n  return signing_key.sign(message)\n\n\n\"\"\"\nverify that a signature is valid for a message\n\"\"\"\ndef verify(verifying_key, signature, message):\n  return verifying_key.verify(signature, message)\n\n\"\"\"\ncreate a signature for a message using a private key\n\"\"\"\ndef sign_message(private_key, message):\n  signing_key ="}
{"query":"\"\"\"\nsign a message using ECDSA signing key\n\"\"\"","temp":0.5,"len":200,"response":"\ndef sign(msg, priv_key):\n    signer = PKCS1_v1_5.new(priv_key)\n    digest = SHA256.new()\n    digest.update(msg)\n    signature = signer.sign(digest)\n    return signature\n\n\"\"\"\nverify a message using ECDSA signing key\n\"\"\"\ndef verify(msg, signature, pub_key):\n    verifier = PKCS1_v1_5.new(pub_key)\n    digest = SHA256.new()\n    digest.update(msg)\n    if verifier.verify(digest, signature):\n        return True\n    else:\n        return False"}
{"query":"\"\"\"\ngenerate ECDSA key\n\"\"\"","temp":0.5,"len":200,"response":"\ndef generate_key():\n    \"\"\"Generate an ECDSA keypair with a curve secp256k1, hex-encoded.\"\"\"\n    # Generate private key\n    priv_key = ecdsa.SigningKey.generate(curve=ecdsa.SECP256k1)\n    pub_key = priv_key.get_verifying_key()\n\n    # Serialize public key to compress format\n    pub_key_serialized = pub_key.to_string()\n    pub_key_compressed = bytes([2 + (pub_key_serialized[64] & 1)]) + pub_key_serialized[0:32]\n\n    return priv_key.to_string().hex(), pub_key_compressed.hex()\n\ndef get_addr(pubkey):\n    pubkey = bytes.fromhex(pubkey)\n    rip"}
