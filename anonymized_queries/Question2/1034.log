{"query":"ECDSA","temp":0,"len":100,"response":"_WITH_AES_128_CBC_SHA256,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t"}
{"query":"\"\"\"\nECDSA signing key function\n\"\"\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t","temp":0,"len":100,"response":"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t"}
{"query":"\"\"\"\nECDSA signing key function\n\"\"\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t","temp":0,"len":100,"response":"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t"}
{"query":"\"\"\"\nECDSA signing key function\n\"\"\"","temp":0.02,"len":100,"response":"\n\nimport os\nimport sys\nimport time\nimport json\nimport base64\nimport hashlib\nimport binascii\nimport logging\nimport argparse\nimport ecdsa\nimport requests\n\nfrom ecdsa import SigningKey, SECP256k1\nfrom ecdsa.util import sigencode_der, sigdecode_der\nfrom ecdsa.keys import VerifyingKey\nfrom ecdsa.curves import SECP256"}
{"query":"\"\"\"\nECDSA signing key function\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport json\nimport base64\nimport hashlib\nimport binascii\nimport logging\nimport argparse\nimport ecdsa\nimport requests\n\nfrom ecdsa import SigningKey, SECP256k1\nfrom ecdsa.util import sigencode_der, sigdecode_der\nfrom ecdsa.keys import VerifyingKey\nfrom ecdsa.curves import SECP256","temp":0.79,"len":100,"response":"k1\nfrom ecdsa.ecdsa import curve_secp256k1\nfrom requests.auth import HTTPBasicAuth\n\ndebug = False\n\ndef sign_message(message, sk):\n\t\"\"\"\n\tSigns a message with a private key (s)\n\t(encoded in base64).\n\n\t:param\tmessage:\tmessage\n\t:param\tsk:\t\t\tSecret key\n\t:return\t\t\t\tSignature"}
{"query":"\"\"\"\nECDSA signing key function\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport json\nimport base64\nimport hashlib\nimport binascii\nimport logging\nimport argparse\nimport ecdsa\nimport requests\n\nfrom ecdsa import SigningKey, SECP256k1\nfrom ecdsa.util import sigencode_der, sigdecode_der\nfrom ecdsa.keys import VerifyingKey\nfrom ecdsa.curves import SECP256k1\nfrom ecdsa.ecdsa import curve_secp256k1\nfrom requests.auth import HTTPBasicAuth\n\ndebug = False\n\ndef sign_message(message, sk):\n\t\"\"\"\n\tSigns a message with a private key (s)\n\t(encoded in base64).\n\n\t:param\tmessage:\tmessage\n\t:param\tsk:\t\t\tSecret key\n\t:return\t\t\t\tSignature","temp":0.98,"len":100,"response":"\n\t\"\"\"\n\thexlify = binascii.hexlify\n\tunhexlify = binascii.unhexlify\n\tif isinstance(message, str):\n\t\tmessage = unhexlify(message)\n\tif isinstance(sk, str):\n\t\tsk = SigningKey.from_string(unhexlify(sk))\n\treturn hexlify(sk.sign_deterministic"}
{"query":"\"\"\"\nECDSA signing key function\n\"\"\"","temp":1,"len":100,"response":"\nimport hashlib\n\nfrom bitcoin.common.compat import range, unhexlify, hexlify\nfrom bitcoin.core.ecdsa import secp256k1_generator, curve_order, ECLTransform\nfrom bitcoin.core.ecdsa.eckey import bytes_to_int, int_to_bytes\n\n# For one-byte length prefixes\ndef secure_hash(message):\n  return bytes_to_int"}
{"query":"\"\"\"\nECDSA signing key function\n\"\"\"\nimport hashlib\n\nfrom bitcoin.common.compat import range, unhexlify, hexlify\nfrom bitcoin.core.ecdsa import secp256k1_generator, curve_order, ECLTransform\nfrom bitcoin.core.ecdsa.eckey import bytes_to_int, int_to_bytes\n\n# For one-byte length prefixes\ndef secure_hash(message):\n  return bytes_to_int","temp":0.65,"len":100,"response":"(hashlib.sha256(message).digest())\n\ndef sign(message, privkey_int):\n    \"\"\"\n    Returns a signature for the given message using the specified private key\n    \"\"\"\n    generator = secp256k1_generator\n    order = curve_order\n    message = secure_hash(message)\n    #print(\"Signing message of length %d bytes\"%len(message))\n    #print(\"  Message"}
{"query":"\"\"\"\nECDSA signing key function\n\"\"\"","temp":0.65,"len":100,"response":"\n\ndef generate_keypair(curve_name):\n\t\"\"\"\n\tGenerates a new ECDSA keypair using the specified curve\n\t\"\"\"\n\t\n\t# choose curve\n\tcurve = get_curve(curve_name)\n\t\n\t# generate keypair\n\tsk = ecdsa.SigningKey.generate(curve=curve)\n\tvk = sk.get_verifying_key()\n"}
{"query":"\"\"\"\nFunction that signs a given message using a given ECDSA signing key\n\"\"\"","temp":0.53,"len":100,"response":"\ndef signMessage(message, privateKey):\n    #Hashing and signing the message\n    signature = sign(message, privateKey)\n\n    #Returning the signature\n    return signature\n\n\"\"\"\nFunction that verifies a given signature using a given ECDSA public key\n\"\"\"\ndef verifySignature(message, signature, publicKey):\n    #Verifying the signature\n    try:\n        verify(message, signature, publicKey)\n        return"}
{"query":"\"\"\"\nFunction that signs a given message using a given ECDSA signing key\n\"\"\"","temp":0.93,"len":100,"response":"\ndef sign(message):\n    priv_key = PrivateKey(flags.FLAGS.priv_key)\n    message_hash = sha256(message)\n    signaturestr = priv_key.sign_digest_deterministic(message_hash, sha256)\n    signature = ECSignature.from_der(signaturestr)\n    return signature"}
{"query":"\"\"\"\nFunction that signs a given message using a given ECDSA signing key\n\"\"\"","temp":0.11,"len":100,"response":"\ndef sign_message(message, signing_key):\n    # Sign the message\n    signature = signing_key.sign(message)\n    # Return the signature\n    return signature\n\n\"\"\"\nFunction that verifies a given signature for a given message using a given ECDSA verification key\n\"\"\"\ndef verify_signature(message, signature, verification_key):\n    # Verify the signature\n    try:\n        verification_key.verify(sign"}
{"query":"\"\"\"\nFunction that signs a given message using a given ECDSA signing key\n\"\"\"","temp":0.11,"len":172,"response":"\ndef sign(message, signing_key):\n    # Convert the message to a hash\n    message_hash = hashlib.sha256(message).digest()\n\n    # Sign the message hash\n    signature = signing_key.sign_digest(message_hash, sigencode=ecdsa.util.sigencode_der)\n\n    # Return the signature\n    return signature\n\n\"\"\"\nFunction that verifies a given signature for a given message using a given ECDSA verifying key\n\"\"\"\ndef verify(message, signature, verifying_key):\n    # Convert the message to a hash\n    message_hash = hashlib.sha256(message).digest()\n\n    # Verify the signature\n    try:\n        verifying_key.verify_digest(sign"}
