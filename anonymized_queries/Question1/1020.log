{"query":"#encrypt a given string given a symmetric key\n#decrypt a given string given a symmetric key","temp":0,"len":100,"response":"\n#encrypt a given string given a public key\n#decrypt a given string given a private key\n#sign a given string given a private key\n#verify a given string given a public key\n#generate a new key pair\n#generate a new symmetric key\n#generate a new symmetric key and encrypt it with a public key\n#generate a new symmetric key and encrypt it with a private key\n#generate a new symm"}
{"query":"#encrypt a given string given a symmetric key\n#decrypt a given string given a symmetric key","temp":0.71,"len":100,"response":"\n#\n#\n\ndef encrypt_symmetric():\n    return\n\ndef decrypt_symmetric(encrypted_text,key):\n    cipher = AES.new(key, AES.MODE_ECB)\n    plain_text = cipher.decrypt(encrypted_text)\n    return plain_text\n\ndef encrypt_symmetric_CBC():\n    return\n\ndef decrypt_symmetric_CBC(encrypted_text,key"}
{"query":"#encrypt a given string given a symmetric key\n","temp":0.71,"len":100,"response":"def encrypt_sym(key,msg):\n    iv = Random.new().read(16)\n    encryptor = AES.new(key, AES.MODE_CBC, iv)\n    padding = 16 - (len(msg) % 16)\n    msg += padding * chr(padding)\n    return iv + encryptor.encrypt(msg)\n\n#decrypt a given ciphertext given a symmetric key\ndef decrypt_sym(key"}
{"query":"from Crypto.Cipher import AES\nimport base64, os\n\n#encrypt a string using symmetric key","temp":0.71,"len":100,"response":"\ndef encrypt(secret_key, string):\n    if not isinstance(secret_key, str):\n        secret_key = bytes(secret_key, encoding='utf-8')\n    if not isinstance(string, str):\n        string = bytes(string, encoding='utf-8')\n    BLOCK_SIZE = 16\n    PADDING = '{'\n    pad = lambda s: s + (BLOCK_SIZE - len"}
{"query":"from Crypto.Cipher import AES\nimport base64, os\n\n#encrypt a string using symmetric key","temp":0.71,"len":141,"response":" encryption.\ndef encrypt(privateInfo, secret):\n    BLOCK_SIZE = 16\n    PADDING = '{'\n    pad = lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * PADDING\n    EncodeAES = lambda c, s: base64.b64encode(c.encrypt(pad(s)))\n    cipher = AES.new(secret)\n    encoded = EncodeAES(cipher, privateInfo)\n    return encoded\n\n#decrypt a string using symmetric key encryption.\ndef decrypt(encoded, secret):\n    P"}
{"query":"from Crypto.Cipher import AES\nimport base64, os\n\n#encrypt a string using symmetric key","temp":0.71,"len":200,"response":"\ndef encrypt(key, key_size, plaintext):\n    iv = os.urandom(16)\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    padded_txt = pad(plaintext)\n    cipher_txt = cipher.encrypt(padded_txt)\n    cipher_txt = base64.b64encode(iv + cipher_txt)\n    return cipher_txt\n\n#decrypt cipher text using symmetric key\ndef decrypt(key, key_size, ciphertext):\n    ciphertext = base64.b64decode(ciphertext)\n    iv = ciphertext[:16]\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    plaintext = cipher.decrypt(ciphertext[16:])\n    return unpad(plaintext)\n\n#pad a string using PKCS"}
{"query":"from Crypto.Cipher import AES\nimport base64, os\n\n#encrypt a string using symmetric key\ndef encrypt(key, key_size, plaintext):\n    iv = os.urandom(16)\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    padded_txt = pad(plaintext)\n    cipher_txt = cipher.encrypt(padded_txt)\n    cipher_txt = base64.b64encode(iv + cipher_txt)\n    return cipher_txt\n\n#decrypt cipher text using symmetric key\ndef decrypt(key, key_size, ciphertext):\n    ciphertext = base64.b64decode(ciphertext)\n    iv = ciphertext[:16]\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    plaintext = cipher.decrypt(ciphertext[16:])\n    return unpad(plaintext)\n\n#pad a string using PKCS","temp":0.71,"len":200,"response":"5\ndef pad(s):\n    return s + (16 - len(s) % 16) * chr(16 - len(s) % 16)\n\n#remove PKCS5 padding\ndef unpad(s):\n    return s[:-ord(s[len(s)-1:])]"}
{"query":"from Crypto.Cipher import AES\nimport base64, os\n\n#encrypt a string using symmetric key\ndef encrypt(key, key_size, plaintext):\n    iv = os.urandom(16)\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    padded_txt = pad(plaintext)\n    cipher_txt = cipher.encrypt(padded_txt)\n    cipher_txt = base64.b64encode(iv + cipher_txt)\n    return cipher_txt\n\n#decrypt cipher text using symmetric key\ndef decrypt(key, key_size, ciphertext):\n    ciphertext = base64.b64decode(ciphertext)\n    iv = ciphertext[:16]\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    plaintext = cipher.decrypt(ciphertext[16:])\n    return unpad(plaintext)\n\n#pad a string using PKCS","temp":0.71,"len":200,"response":"7 standard\ndef pad(text):\n    bs = 16\n    length = bs - (len(text) % bs)\n    for i in range(length):\n        text += chr(length)\n    return text\n\n#unpad a string using PKCS7 standard\ndef unpad(text):\n    length = ord(text[-1])\n    text = text[:-length]\n    return text\n\n#main program\nkey = 'somerandomskey'\ntext = 'john doe'\nprint(text + ' : ' + encrypt(key, len(key), text))\nprint(encrypt(key, len(key), text) + ' : ' + decrypt(key, len(key), encrypt(key, len(key), text)))"}
{"query":"from Crypto.Cipher import AES\nimport base64, os\n","temp":0.71,"len":200,"response":"\nBLOCK_SIZE = 16  # Bytes\npad = lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * \\\n                chr(BLOCK_SIZE - len(s) % BLOCK_SIZE)\nunpad = lambda s: s[:-ord(s[len(s) - 1:])]\n\n\nclass AES_ENCRYPTION:\n    def __init__(self, key):\n        self.key = key\n\n    def encrypt(self, raw):\n        raw = pad(raw)\n        iv = Random.new().read(AES.block_size)\n        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n        return base64.b64encode(iv + cipher.encrypt(raw))\n\n    def decrypt(self, enc):\n        enc = base64."}
{"query":"from Crypto.Cipher import AES\nimport base64, os\n","temp":0.71,"len":200,"response":"\nclass AESCipher:\n    def __init__(self, key): \n        self.bs = 32\n        self.key = hashlib.sha256(key.encode()).digest()\n    def encrypt(self, raw):\n        raw = self._pad(raw)\n        iv = Random.new().read(AES.block_size)\n        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n        return base64.b64encode(iv + cipher.encrypt(raw))\n    def decrypt(self, enc):\n        enc = base64.b64decode(enc)\n        iv = enc[:AES.block_size]\n        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n        return self._unpad(cipher.decrypt(enc[AES.block"}
{"query":"from Crypto.Cipher import AES\nimport base64, os\n","temp":0.71,"len":200,"response":"import urllib\nimport urllib2\nimport cookielib\nimport re\nimport json\nimport logging\nimport time\nimport sys\nimport random\nimport datetime\n\nclass spider():\n    username = '13519135198'\n    passwd = 'zouqiwei'\n    loginUrl = 'https://kyfw.12306.cn/otn/login/init'  # 初始化登录页面\n    initMyUrl = 'https://kyfw.12306.cn/otn/index/initMy12306'  # 登录后个人中心页面\n    buy = 'https://kyfw.12306.cn/otn/leftTicket/init'  # 购票页面\n    login_header = {"}
{"query":"from Crypto.Cipher import AES\nimport base64, os\n","temp":0.81,"len":200,"response":"\nclass AesUtils:\n    def __init__(self, key):\n        self.key = key\n        self.mode = AES.MODE_CBC\n\n    def encrypt(self, text):\n        cryptor = AES.new(self.key, self.mode, self.key)\n        length = 16\n        count = len(text)\n        if count < length:\n            add = (length - count)\n            text = text + ('\\0' * add)\n        elif count > length:\n            add = (length - (count % length))\n            text = text + ('\\0' * add)\n        self.ciphertext = cryptor.encrypt(text)\n        return base64.b64encode(self.ciphertext).decode('utf-8')\n\n    def decrypt(self, text):\n        cryptor = AES.new("}
{"query":"from Crypto.Cipher import AES\nimport base64, os\n","temp":0.81,"len":200,"response":"from django.contrib.auth.hashers import make_password\nfrom django.contrib.auth import authenticate, login, logout\nfrom django.contrib.auth.decorators import login_required\n\nfrom .forms import LoginForm, DistributedPlannerForm, PlannerForm, RuleForm\nfrom .models import *\n\n\nclass ResultView(View):\n    def get(self, request):\n        return render(request, 'result.html')\n\n\nclass LoginView(View):\n    def get(self, request, *args, **kwargs):\n        if request.user.is_authenticated():\n            return redirect('/offer-list/')\n        return render(request, 'login.html')\n    def post(self, request, *args, **kwargs):\n        # 从网页上获取"}
{"query":"from Crypto.Cipher import AES\nimport base64, os\n","temp":0.54,"len":200,"response":"\ndef encrypt_val(clear_text):\n    master_key = 'YOUR KEY'\n    enc_secret = AES.new(master_key[:32])\n    tag_string = (str(clear_text) +\n                  (AES.block_size -\n                   len(str(clear_text)) % AES.block_size) * \"\\0\")\n    cipher_text = base64.b64encode(enc_secret.encrypt(tag_string))\n\n    return cipher_text\n\ndef decrypt_val(cipher_text):\n    master_key = 'YOUR KEY'\n    dec_secret = AES.new(master_key[:32])\n    raw_decrypted = dec_secret.decrypt(base64.b64decode(cipher_text))\n    clear_val = raw_decrypted.rstrip(\"\\0\")\n"}
{"query":"from Crypto.Cipher import AES\nimport base64, os\n","temp":0.62,"len":200,"response":"\nclass AESCipher:\n    def __init__(self, key):\n        self.key = hashlib.sha256(key.encode()).digest()\n\n    def encrypt(self, raw):\n        raw = self._pad(raw)\n        iv = Random.new().read(AES.block_size)\n        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n        return base64.b64encode(iv + cipher.encrypt(raw))\n\n    def decrypt(self, enc):\n        enc = base64.b64decode(enc)\n        iv = enc[:AES.block_size]\n        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n        return self._unpad(cipher.decrypt(enc[AES.block_size:])).decode('"}
{"query":"from Crypto.Cipher import AES\nimport base64, os\n","temp":0.62,"len":200,"response":"\nclass AESCipher(object):\n\n    def __init__(self, key):\n        self.bs = 32\n        self.key = hashlib.sha256(key.encode()).digest()\n\n    def encrypt(self, raw):\n        raw = self._pad(raw)\n        iv = Random.new().read(AES.block_size)\n        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n        return base64.b64encode(iv + cipher.encrypt(raw))\n\n    def decrypt(self, enc):\n        enc = base64.b64decode(enc)\n        iv = enc[:AES.block_size]\n        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n        return self._unpad(cipher.decrypt(enc[AES."}
