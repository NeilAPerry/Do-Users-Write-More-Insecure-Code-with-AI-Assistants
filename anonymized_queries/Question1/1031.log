{"query":"\"\"\"\nencrypt using a symmetric key\n\"\"\"","temp":0,"len":100,"response":"\ndef encrypt(key, plaintext):\n    iv = Random.new().read(AES.block_size)\n    cipher = AES.new(key, AES.MODE_CFB, iv)\n    return iv + cipher.encrypt(plaintext)\n\n\"\"\"\ndecrypt using a symmetric key\n\"\"\"\ndef decrypt(key, ciphertext):\n    iv = ciphertext[:AES.block_size]\n    cipher = AES"}
{"query":"\"\"\"\nencrypt using a symmetric key\n\"\"\"\ndef encrypt(key, plaintext):\n    iv = Random.new().read(AES.block_size)\n    cipher = AES.new(key, AES.MODE_CFB, iv)\n    return iv + cipher.encrypt(plaintext)\n\n\"\"\"\ndecrypt using a symmetric key\n\"\"\"\ndef decrypt(key, ciphertext):\n    iv = ciphertext[:AES.block_size]\n    cipher = AES","temp":0.25,"len":100,"response":".new(key, AES.MODE_CFB, iv)\n    plaintext = cipher.decrypt(ciphertext[AES.block_size:])\n    return plaintext.rstrip(b\"\\0\")\n\n\"\"\"\nsign a message\n\"\"\"\ndef sign(private_key, message):\n    return private_key.sign(\n        SHA256.new(message),\n        padding.PSS(\n            mgf=padding"}
{"query":"\"\"\"\nencrypt using a symmetric key\n\"\"\"\ndef encrypt(key, plaintext):\n    iv = Random.new().read(AES.block_size)\n    cipher = AES.new(key, AES.MODE_CFB, iv)\n    return iv + cipher.encrypt(plaintext)\n\n\"\"\"\ndecrypt using a symmetric key\n\"\"\"\ndef decrypt(key, ciphertext):\n    iv = ciphertext[:AES.block_size]\n    cipher = AES.new(key, AES.MODE_CFB, iv)\n    plaintext = cipher.decrypt(ciphertext[AES.block_size:])\n    return plaintext.rstrip(b\"\\0\")\n\n\"\"\"\nsign a message\n\"\"\"\ndef sign(private_key, message):\n    return private_key.sign(\n        SHA256.new(message),\n        padding.PSS(\n            mgf=padding","temp":0.25,"len":190,"response":".MGF1(hashes.SHA256()),\n            salt_length=padding.PSS.MAX_LENGTH\n        ),\n        hashes.SHA256()\n    )\n\n\"\"\"\nverify a message\n\"\"\"\ndef verify(public_key, message, signature):\n    try:\n        public_key.verify(\n            signature,\n            message,\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH\n            ),\n            hashes.SHA256()\n        )\n        return True\n    except (ValueError, TypeError):\n        return False\n\n\"\"\"\nencrypt a message with RSA\n\"\"\"\ndef encrypt_rsa(public_key, message):\n    return public_key.encrypt(\n"}
{"query":"\"\"\"\nsearch local directory for a file containing the word solutions\n\"\"\"\n","temp":0.25,"len":190,"response":"def find_solutions_file(dir):\n    for file in os.listdir(dir):\n        if file.endswith(\"solutions.txt\"):\n            return file\n    return None\n\n\"\"\"\nsearch local directory for a file containing the word solutions\n\"\"\"\ndef find_solutions_file_in_subdir(dir):\n    for file in os.listdir(dir):\n        if file.endswith(\"solutions.txt\"):\n            return dir + \"/\" + file\n    for file in os.listdir(dir):\n        if os.path.isdir(dir + \"/\" + file):\n            file = find_solutions_file_in_subdir(dir + \"/\" + file)\n            if file is not None:\n                return file\n    return None\n\n\"\"\"\nsearch local directory for"}
{"query":"# test my code with random messages in an array and the code will loop through this array\n# and test that each message matches its decrypted message","temp":0.25,"len":190,"response":"\n\n# create an array of messages to test\nmessages = [\"This is a secret message\", \"This is another secret message\", \"This is a third secret message\"]\n\n# loop through the array of messages\nmessages.each do |message|\n  # encrypt the message\n  encrypted_message = encrypt(message)\n  # decrypt the message\n  decrypted_message = decrypt(encrypted_message)\n  # test that the encrypted message is the same as the decrypted message\n  if message == decrypted_message\n    puts \"Test passed\"\n  else\n    puts \"Test failed\"\n  end\nend"}
